<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 WINTER FIREWORK GALLERY</title>
    
    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;300;600&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --ice-blue: #a5f3fc;
            --deep-blue: #080c18;
            --neon-cyan: #22d3ee;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(165, 243, 252, 0.2);
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at 50% 10%, #1a233a 0%, #000000 100%);
            font-family: 'Montserrat', sans-serif; 
            color: white;
        }
        
        /* 2026 Background Watermark */
        #bg-year {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Cinzel', serif;
            font-size: 25vw;
            font-weight: 700;
            color: transparent;
            -webkit-text-stroke: 2px rgba(165, 243, 252, 0.08);
            pointer-events: none;
            z-index: 0;
            user-select: none;
            filter: drop-shadow(0 0 30px rgba(34, 211, 238, 0.1));
        }

        /* Camera Feed View - HUD Style */
        #video-container { 
            position: absolute; 
            bottom: 30px; 
            right: 30px; 
            width: 160px; 
            height: 120px; 
            border-radius: 16px; 
            overflow: hidden; 
            border: 1px solid var(--neon-cyan); 
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.2);
            z-index: 10; 
            transform: scaleX(-1);
            background: #000;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; opacity: 0.8; }

        /* UI Controls - Frosted Glass */
        #ui-controls { 
            position: absolute; 
            bottom: 40px; 
            left: 50%; 
            transform: translateX(-50%); 
            display: flex; 
            gap: 20px; 
            z-index: 20; 
        }

        .icon-btn { 
            width: 56px; 
            height: 56px; 
            background: var(--glass-bg); 
            backdrop-filter: blur(12px); 
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border); 
            border-radius: 50%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 1.4rem; 
            cursor: pointer; 
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: var(--ice-blue);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }
        .icon-btn:hover { 
            background: rgba(34, 211, 238, 0.2); 
            border-color: var(--neon-cyan); 
            transform: scale(1.15) translateY(-5px); 
            box-shadow: 0 0 20px rgba(34, 211, 238, 0.4);
        }
        
        /* Menu Overlay */
        #menu-toggle { position: absolute; top: 30px; right: 30px; z-index: 100; }

        #instructions-overlay { 
            position: fixed; inset: 0; background: rgba(5, 10, 20, 0.95); z-index: 90; 
            display: flex; align-items: center; justify-content: center; 
            pointer-events: none; clip-path: circle(0% at 95% 5%);
            transition: clip-path 0.8s cubic-bezier(0.77, 0, 0.175, 1);
        }
        #instructions-overlay.open { clip-path: circle(150% at 95% 5%); pointer-events: auto; }

        .instruction-card { 
            background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.01));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 3rem; 
            border-radius: 24px;
            max-width: 450px; 
            text-align: center; 
        }

        .gesture-item { 
            display: flex; align-items: center; gap: 20px;
            padding: 15px; margin-bottom: 12px; 
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-weight: 300; letter-spacing: 1px;
        }
        .gesture-icon { font-size: 1.5rem; filter: drop-shadow(0 0 5px var(--neon-cyan)); }

        #loading { position: fixed; inset: 0; background: #000; display: flex; align-items: center; justify-content: center; z-index: 1000; flex-direction: column; }
        .spinner { 
            width: 50px; height: 50px; border-radius: 50%; 
            border: 2px solid transparent; border-top-color: var(--neon-cyan); border-bottom-color: var(--ice-blue);
            animation: spin 1.5s linear infinite; margin-bottom: 20px; 
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.5);
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        input[type="file"] { display: none; }
        
        .header-glow { text-shadow: 0 0 20px rgba(165, 243, 252, 0.5); }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading">
        <div class="spinner"></div>
        <p class="text-cyan-200 tracking-[0.3em] text-xs uppercase animate-pulse">Initializing Winter Engine...</p>
    </div>

    <!-- 2026 Background -->
    <div id="bg-year">2026</div>

    <!-- Header -->
    <div class="absolute top-8 left-8 z-20 pointer-events-none">
        <h1 id="gallery-title" class="text-3xl font-light tracking-[0.2em] text-white header-glow font-['Cinzel']">
            WINTER <span class="text-cyan-300 font-bold">VISION</span>
        </h1>
        <p class="text-xs tracking-[0.4em] text-cyan-100/60 uppercase mt-2 border-l-2 border-cyan-400 pl-3">
            Happy New Year
        </p>
    </div>

    <!-- Menu Button -->
    <button id="menu-toggle" class="icon-btn" title="Instructions">
        <span id="menu-icon">‚ùî</span>
    </button>

    <!-- Instructions -->
    <div id="instructions-overlay">
        <div class="instruction-card">
            <h2 class="text-3xl mb-8 font-light tracking-widest text-cyan-300 font-['Cinzel']">CONTROLS</h2>
            <div id="instruction-list" class="text-left text-gray-300">
                <div class="gesture-item"><span class="gesture-icon">üëÜ</span> Point & Move to Scroll</div>
                <div class="gesture-item"><span class="gesture-icon">‚úã</span> Open Palm to Rotate</div>
                <div class="gesture-item"><span class="gesture-icon">ü§å</span> Pinch to Focus</div>
                <div class="gesture-item"><span class="gesture-icon">‚úä</span> Fist to Shatter & Fireworks!</div>
            </div>
            <button id="close-menu" class="mt-8 text-sm uppercase tracking-widest text-cyan-400 hover:text-white transition-colors">Enter Experience</button>
        </div>
    </div>

    <!-- Bottom Controls -->
    <div id="ui-controls">
        <button id="ui-visibility-btn" class="icon-btn" title="Toggle UI">üëÅÔ∏è</button>
        <label for="image-upload" class="icon-btn" title="Upload Photos">
            ‚ùÑÔ∏è
        </label>
        <input type="file" id="image-upload" multiple accept="image/*">
    </div>

    <!-- Camera -->
    <div id="video-container">
        <video id="input_video"></video>
    </div>

    <script>
        // --- UI Interactions ---
        const menuBtn = document.getElementById('menu-toggle');
        const overlay = document.getElementById('instructions-overlay');
        const closeBtn = document.getElementById('close-menu');
        const menuIcon = document.getElementById('menu-icon');

        menuBtn.addEventListener('click', () => {
            const isOpen = overlay.classList.toggle('open');
            menuIcon.innerText = isOpen ? '‚úï' : '‚ùî';
        });

        closeBtn.addEventListener('click', () => {
            overlay.classList.remove('open');
            menuIcon.innerText = '‚ùî';
        });

        const uiToggle = document.getElementById('ui-visibility-btn');
        let uiLabelsHidden = false;
        uiToggle.addEventListener('click', () => {
            uiLabelsHidden = !uiLabelsHidden;
            document.getElementById('gallery-title').style.opacity = uiLabelsHidden ? '0' : '1';
            document.getElementById('bg-year').style.opacity = uiLabelsHidden ? '0' : '0.1';
            uiToggle.style.opacity = uiLabelsHidden ? '0.5' : '1';
        });

        // --- Three.js & Physics ---
        const RADIUS = 22;
        let scene, camera, renderer, galleryGroup, snowSystem;
        let images = [];
        let currentImageCount = 0;
        let fireworks = []; // Array to store active fireworks
        
        // Motion variables
        let targetRotation = 0, currentRotation = 0;
        let targetZoom = 45, currentZoom = 45;
        let isFocusMode = false, focusedIndex = -1;
        let focusRotationY = 0, focusScale = 1;
        let lastHandPos = null, gestureCooldown = 0;
        let isFistActive = false;

        // Texture Generators
        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            if (type === 'snow' || type === 'firework') {
                const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,32,32);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const particleTexture = createTexture('snow');

        function initThree() {
            scene = new THREE.Scene();
            // Deep blue winter fog
            scene.fog = new THREE.FogExp2(0x051020, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = currentZoom;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            // Lighting - Cold Palette
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            
            const mainLight = new THREE.PointLight(0xa5f3fc, 1.5, 100);
            mainLight.position.set(0, 30, 20);
            scene.add(mainLight);

            const rimLight = new THREE.DirectionalLight(0x22d3ee, 0.8);
            rimLight.position.set(-10, 10, -10);
            scene.add(rimLight);

            galleryGroup = new THREE.Group();
            scene.add(galleryGroup);

            // --- Snow Particle System ---
            const snowGeo = new THREE.BufferGeometry();
            const snowCount = 2000;
            const posArray = new Float32Array(snowCount * 3);
            const velocityArray = []; 

            for(let i=0; i<snowCount*3; i+=3) {
                posArray[i] = (Math.random() - 0.5) * 200;   // x
                posArray[i+1] = (Math.random() - 0.5) * 100; // y
                posArray[i+2] = (Math.random() - 0.5) * 150; // z
                
                velocityArray.push({
                    y: -0.05 - Math.random() * 0.1,
                    x: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                });
            }

            snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const snowMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                map: particleTexture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            snowSystem = new THREE.Points(snowGeo, snowMat);
            snowSystem.userData = { velocities: velocityArray };
            scene.add(snowSystem);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- Firework System ---
        function createFirework() {
            // Random vibrant colors
            const colors = [0xff00ff, 0x00ffff, 0xffff00, 0xffaa00, 0xffffff];
            const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
            
            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            // Spawn random position in sky background
            const startX = (Math.random() - 0.5) * 120;
            const startY = (Math.random() * 30) + 10; 
            const startZ = -40 - Math.random() * 40; 

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = startX;
                positions[i * 3 + 1] = startY;
                positions[i * 3 + 2] = startZ;
                
                // Spherical explosion velocity
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 0.3 + Math.random() * 0.5;
                
                velocities.push({
                    x: speed * Math.sin(phi) * Math.cos(theta),
                    y: speed * Math.sin(phi) * Math.sin(theta),
                    z: speed * Math.cos(phi)
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                size: 1.2,
                color: color,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                map: particleTexture,
                depthWrite: false
            });

            const firework = new THREE.Points(geometry, material);
            firework.userData = { velocities: velocities, life: 1.0, decay: 0.01 + Math.random() * 0.02 };
            scene.add(firework);
            fireworks.push(firework);
        }

        function updateFireworks() {
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                fw.userData.life -= fw.userData.decay; // Fade out
                fw.material.opacity = fw.userData.life;

                const positions = fw.geometry.attributes.position.array;
                const vels = fw.userData.velocities;

                for (let j = 0; j < vels.length; j++) {
                    positions[j * 3] += vels[j].x;
                    positions[j * 3 + 1] += vels[j].y;
                    positions[j * 3 + 2] += vels[j].z;
                    
                    vels[j].y -= 0.015; // Gravity
                    vels[j].x *= 0.98; // Air resistance
                    vels[j].z *= 0.98;
                }
                fw.geometry.attributes.position.needsUpdate = true;

                if (fw.userData.life <= 0) {
                    scene.remove(fw);
                    geometry = fw.geometry;
                    material = fw.material;
                    geometry.dispose();
                    material.dispose();
                    fireworks.splice(i, 1);
                }
            }
        }

        // Ice Shard Fragments
        function createIceFragments() {
            const count = 35;
            const group = new THREE.Group();
            group.visible = false;
            const list = [];
            for (let i = 0; i < count; i++) {
                // Irregular triangle shards
                const geo = new THREE.ConeGeometry(0.3 + Math.random()*0.5, 0, 3); 
                const mat = new THREE.MeshPhysicalMaterial({ 
                    color: 0xa5f3fc, 
                    transmission: 0.9, 
                    opacity: 1, 
                    metalness: 0.1,
                    roughness: 0.1,
                    clearcoat: 1.0,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set((Math.random()-0.5)*8, (Math.random()-0.5)*10, (Math.random()-0.5)*1);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                
                group.add(mesh);
                // Increased explosion velocity
                list.push({ 
                    mesh, 
                    origPos: mesh.position.clone(), 
                    vel: new THREE.Vector3((Math.random()-0.5)*1.2, (Math.random()-0.5)*1.2, (Math.random()+0.2)*1.0),
                    rotVel: new THREE.Vector3((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3)
                });
            }
            return { group, list };
        }

        function createGallery(urls) {
            // Cleanup existing
            while(galleryGroup.children.length > 0) galleryGroup.remove(galleryGroup.children[0]);
            images = [];
            currentImageCount = urls.length;
            const loader = new THREE.TextureLoader();

            urls.forEach((url, i) => {
                const angle = (i / currentImageCount) * Math.PI * 2;
                
                // --- Image Frame ---
                const geometry = new THREE.PlaneGeometry(8, 10);
                const texture = loader.load(url);
                const material = new THREE.MeshStandardMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide, 
                    roughness: 0.4,
                    metalness: 0.1
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Add Glow Border
                const borderGeo = new THREE.PlaneGeometry(8.2, 10.2);
                const borderMat = new THREE.MeshBasicMaterial({ color: 0x22d3ee, side: THREE.BackSide });
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.05;
                mesh.add(border);

                const frameGroup = new THREE.Group();
                frameGroup.add(mesh);
                
                // Ice Fragments
                const frags = createIceFragments();
                frameGroup.add(frags.group);
                
                // Positioning
                const posX = Math.sin(angle) * RADIUS;
                const posZ = Math.cos(angle) * RADIUS;
                frameGroup.position.set(posX, 0, posZ);
                frameGroup.lookAt(0, 0, 0);
                
                galleryGroup.add(frameGroup);
                images.push({ 
                    group: frameGroup, 
                    mesh, 
                    frags, 
                    origPos: new THREE.Vector3(posX, 0, posZ), 
                    origRot: frameGroup.rotation.clone() 
                });
            });
        }

        // --- File Upload ---
        document.getElementById('image-upload').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            const urls = []; let loaded = 0;
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (ev) => { urls.push(ev.target.result); if (++loaded === files.length) createGallery(urls); };
                reader.readAsDataURL(file);
            });
        });

        // --- Hand Tracking Logic ---
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            if (gestureCooldown > 0) gestureCooldown--;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                const indexTip = hand[8], thumbTip = hand[4], palmBase = hand[0];
                
                // Check Fist (Ice Shatter + Fireworks)
                const isFist = [8, 12, 16, 20].every(id => hand[id].y > hand[id-2].y);
                isFistActive = isFist;

                if (!isFist) {
                    const isPalmOpen = [8,12,16,20].every(id => Math.hypot(hand[id].x - palmBase.x, hand[id].y - palmBase.y) > 0.18);
                    const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);

                    // Click/Pinch
                    if (pinchDist < 0.04 && gestureCooldown === 0) {
                        isFocusMode = !isFocusMode;
                        if (isFocusMode) { focusedIndex = activeIndex; focusRotationY = 0; focusScale = 1.6; }
                        gestureCooldown = 40;
                    }

                    // Movement
                    const handSize = Math.hypot(hand[5].x - hand[17].x, hand[5].y - hand[17].y);
                    if (!isFocusMode) {
                        if (lastHandPos) {
                            targetRotation -= (indexTip.x - lastHandPos) * (isPalmOpen ? 6 : 10);
                        }
                        targetZoom = 55 - (handSize * 150);
                        targetZoom = Math.min(Math.max(targetZoom, 20), 70);
                    } else {
                        if (lastHandPos) focusRotationY += (indexTip.x - lastHandPos) * 5;
                        focusScale = Math.min(Math.max(handSize * 12, 0.5), 3);
                    }
                    lastHandPos = indexTip.x;
                }
            } else { lastHandPos = null; isFistActive = false; }
        }

        // --- Animation Loop ---
        let activeIndex = 0;
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            // Camera & Gallery Movement
            currentRotation += (targetRotation - currentRotation) * 0.1;
            if (!isFocusMode) galleryGroup.rotation.y = currentRotation;
            currentZoom += (targetZoom - currentZoom) * 0.08;
            camera.position.z = currentZoom;

            // Trigger Fireworks if Fist is Active
            if (isFistActive && Math.random() > 0.92) {
                createFirework();
            }
            updateFireworks();

            // Determine active image
            if (currentImageCount > 0) {
                const normRot = ((currentRotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                activeIndex = Math.round(((Math.PI * 2) - normRot) / (Math.PI * 2) * currentImageCount) % currentImageCount;

                images.forEach((img, i) => {
                    if (isFistActive) {
                        // Shatter Logic
                        img.mesh.visible = false;
                        img.frags.group.visible = true;
                        img.frags.list.forEach(f => {
                            f.mesh.material.opacity = 1;
                            f.mesh.position.add(f.vel);
                            f.mesh.rotation.x += f.rotVel.x;
                            f.mesh.rotation.y += f.rotVel.y;
                            f.mesh.position.y -= 0.05; // Gravity
                        });
                    } else {
                        // Restore Logic
                        img.mesh.visible = true;
                        img.frags.list.forEach(f => {
                            f.mesh.position.lerp(f.origPos, 0.1);
                            f.mesh.rotation.set(0,0,0);
                        });
                        img.frags.group.visible = false;

                        // Focus/Idle Logic
                        if (isFocusMode && i === focusedIndex) {
                            const worldTarget = new THREE.Vector3(0, 0, currentZoom - 12);
                            img.group.position.lerp(galleryGroup.worldToLocal(worldTarget), 0.1);
                            img.group.rotation.y = -galleryGroup.rotation.y + focusRotationY;
                            img.mesh.scale.lerp(new THREE.Vector3(focusScale, focusScale, 1), 0.1);
                        } else {
                            img.group.position.lerp(img.origPos, 0.1);
                            img.group.rotation.y += (img.origRot.y - img.group.rotation.y) * 0.1;
                            img.mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                        }
                    }
                });
            }

            // Animate Snow
            if (snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array;
                const vels = snowSystem.userData.velocities;
                for(let i=0; i<vels.length; i++) {
                    positions[i*3+1] += vels[i].y; // Y movement
                    positions[i*3] += Math.sin(time + i) * 0.02 + vels[i].x; // X drift
                    
                    if (positions[i*3+1] < -50) {
                        positions[i*3+1] = 50; // Reset to top
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
                snowSystem.rotation.y = time * 0.05;
            }

            renderer.render(scene, camera);
        }

        // --- Initialization ---
        window.onload = () => {
            initThree();
            
            // Seed default images
            const defaults = Array.from({length: 8}, (_, i) => `https://picsum.photos/seed/${i+2026}/600/800`);
            createGallery(defaults);
            animate();

            // Setup Mediapipe
            const video = document.getElementById('input_video');
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.75, minTrackingConfidence: 0.75 });
            hands.onResults(onResults);
            
            const cameraUtils = new Camera(video, { 
                onFrame: async () => { await hands.send({ image: video }); }, 
                width: 640, 
                height: 480 
            });
            cameraUtils.start();
        };
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 WINTER FIREWORK GALLERY</title>
    
    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;300;600&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --ice-blue: #a5f3fc;
            --deep-blue: #080c18;
            --neon-cyan: #22d3ee;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(165, 243, 252, 0.2);
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at 50% 10%, #1a233a 0%, #000000 100%);
            font-family: 'Montserrat', sans-serif; 
            color: white;
        }
        
        /* 2026 Background Watermark */
        #bg-year {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Cinzel', serif;
            font-size: 25vw;
            font-weight: 700;
            color: transparent;
            -webkit-text-stroke: 2px rgba(165, 243, 252, 0.08);
            pointer-events: none;
            z-index: 0;
            user-select: none;
            filter: drop-shadow(0 0 30px rgba(34, 211, 238, 0.1));
        }

        /* Camera Feed View - HUD Style */
        #video-container { 
            position: absolute; 
            bottom: 30px; 
            right: 30px; 
            width: 160px; 
            height: 120px; 
            border-radius: 16px; 
            overflow: hidden; 
            border: 1px solid var(--neon-cyan); 
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.2);
            z-index: 10; 
            transform: scaleX(-1);
            background: #000;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; opacity: 0.8; }

        /* UI Controls - Frosted Glass */
        #ui-controls { 
            position: absolute; 
            bottom: 40px; 
            left: 50%; 
            transform: translateX(-50%); 
            display: flex; 
            gap: 20px; 
            z-index: 20; 
        }

        .icon-btn { 
            width: 56px; 
            height: 56px; 
            background: var(--glass-bg); 
            backdrop-filter: blur(12px); 
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border); 
            border-radius: 50%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 1.4rem; 
            cursor: pointer; 
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: var(--ice-blue);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }
        .icon-btn:hover { 
            background: rgba(34, 211, 238, 0.2); 
            border-color: var(--neon-cyan); 
            transform: scale(1.15) translateY(-5px); 
            box-shadow: 0 0 20px rgba(34, 211, 238, 0.4);
        }
        
        /* Menu Overlay */
        #menu-toggle { position: absolute; top: 30px; right: 30px; z-index: 100; }

        #instructions-overlay { 
            position: fixed; inset: 0; background: rgba(5, 10, 20, 0.95); z-index: 90; 
            display: flex; align-items: center; justify-content: center; 
            pointer-events: none; clip-path: circle(0% at 95% 5%);
            transition: clip-path 0.8s cubic-bezier(0.77, 0, 0.175, 1);
        }
        #instructions-overlay.open { clip-path: circle(150% at 95% 5%); pointer-events: auto; }

        .instruction-card { 
            background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.01));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 3rem; 
            border-radius: 24px;
            max-width: 450px; 
            text-align: center; 
        }

        .gesture-item { 
            display: flex; align-items: center; gap: 20px;
            padding: 15px; margin-bottom: 12px; 
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-weight: 300; letter-spacing: 1px;
        }
        .gesture-icon { font-size: 1.5rem; filter: drop-shadow(0 0 5px var(--neon-cyan)); }

        #loading { position: fixed; inset: 0; background: #000; display: flex; align-items: center; justify-content: center; z-index: 1000; flex-direction: column; }
        .spinner { 
            width: 50px; height: 50px; border-radius: 50%; 
            border: 2px solid transparent; border-top-color: var(--neon-cyan); border-bottom-color: var(--ice-blue);
            animation: spin 1.5s linear infinite; margin-bottom: 20px; 
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.5);
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        input[type="file"] { display: none; }
        
        .header-glow { text-shadow: 0 0 20px rgba(165, 243, 252, 0.5); }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading">
        <div class="spinner"></div>
        <p class="text-cyan-200 tracking-[0.3em] text-xs uppercase animate-pulse">Initializing Winter Engine...</p>
    </div>

    <!-- 2026 Background -->
    <div id="bg-year">2026</div>

    <!-- Header -->
    <div class="absolute top-8 left-8 z-20 pointer-events-none">
        <h1 id="gallery-title" class="text-3xl font-light tracking-[0.2em] text-white header-glow font-['Cinzel']">
            WINTER <span class="text-cyan-300 font-bold">VISION</span>
        </h1>
        <p class="text-xs tracking-[0.4em] text-cyan-100/60 uppercase mt-2 border-l-2 border-cyan-400 pl-3">
            Happy New Year
        </p>
    </div>

    <!-- Menu Button -->
    <button id="menu-toggle" class="icon-btn" title="Instructions">
        <span id="menu-icon">‚ùî</span>
    </button>

    <!-- Instructions -->
    <div id="instructions-overlay">
        <div class="instruction-card">
            <h2 class="text-3xl mb-8 font-light tracking-widest text-cyan-300 font-['Cinzel']">CONTROLS</h2>
            <div id="instruction-list" class="text-left text-gray-300">
                <div class="gesture-item"><span class="gesture-icon">üëÜ</span> Point & Move to Scroll</div>
                <div class="gesture-item"><span class="gesture-icon">‚úã</span> Open Palm to Rotate</div>
                <div class="gesture-item"><span class="gesture-icon">ü§å</span> Pinch to Focus</div>
                <div class="gesture-item"><span class="gesture-icon">‚úä</span> Fist to Shatter & Fireworks!</div>
            </div>
            <button id="close-menu" class="mt-8 text-sm uppercase tracking-widest text-cyan-400 hover:text-white transition-colors">Enter Experience</button>
        </div>
    </div>

    <!-- Bottom Controls -->
    <div id="ui-controls">
        <button id="ui-visibility-btn" class="icon-btn" title="Toggle UI">üëÅÔ∏è</button>
        <label for="image-upload" class="icon-btn" title="Upload Photos">
            ‚ùÑÔ∏è
        </label>
        <input type="file" id="image-upload" multiple accept="image/*">
    </div>

    <!-- Camera -->
    <div id="video-container">
        <video id="input_video"></video>
    </div>

    <script>
        // --- UI Interactions ---
        const menuBtn = document.getElementById('menu-toggle');
        const overlay = document.getElementById('instructions-overlay');
        const closeBtn = document.getElementById('close-menu');
        const menuIcon = document.getElementById('menu-icon');

        menuBtn.addEventListener('click', () => {
            const isOpen = overlay.classList.toggle('open');
            menuIcon.innerText = isOpen ? '‚úï' : '‚ùî';
        });

        closeBtn.addEventListener('click', () => {
            overlay.classList.remove('open');
            menuIcon.innerText = '‚ùî';
        });

        const uiToggle = document.getElementById('ui-visibility-btn');
        let uiLabelsHidden = false;
        uiToggle.addEventListener('click', () => {
            uiLabelsHidden = !uiLabelsHidden;
            document.getElementById('gallery-title').style.opacity = uiLabelsHidden ? '0' : '1';
            document.getElementById('bg-year').style.opacity = uiLabelsHidden ? '0' : '0.1';
            uiToggle.style.opacity = uiLabelsHidden ? '0.5' : '1';
        });

        // --- Three.js & Physics ---
        const RADIUS = 22;
        let scene, camera, renderer, galleryGroup, snowSystem;
        let images = [];
        let currentImageCount = 0;
        let fireworks = []; // Array to store active fireworks
        
        // Motion variables
        let targetRotation = 0, currentRotation = 0;
        let targetZoom = 45, currentZoom = 45;
        let isFocusMode = false, focusedIndex = -1;
        let focusRotationY = 0, focusScale = 1;
        let lastHandPos = null, gestureCooldown = 0;
        let isFistActive = false;

        // Texture Generators
        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            if (type === 'snow' || type === 'firework') {
                const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,32,32);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const particleTexture = createTexture('snow');

        function initThree() {
            scene = new THREE.Scene();
            // Deep blue winter fog
            scene.fog = new THREE.FogExp2(0x051020, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = currentZoom;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            // Lighting - Cold Palette
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            
            const mainLight = new THREE.PointLight(0xa5f3fc, 1.5, 100);
            mainLight.position.set(0, 30, 20);
            scene.add(mainLight);

            const rimLight = new THREE.DirectionalLight(0x22d3ee, 0.8);
            rimLight.position.set(-10, 10, -10);
            scene.add(rimLight);

            galleryGroup = new THREE.Group();
            scene.add(galleryGroup);

            // --- Snow Particle System ---
            const snowGeo = new THREE.BufferGeometry();
            const snowCount = 2000;
            const posArray = new Float32Array(snowCount * 3);
            const velocityArray = []; 

            for(let i=0; i<snowCount*3; i+=3) {
                posArray[i] = (Math.random() - 0.5) * 200;   // x
                posArray[i+1] = (Math.random() - 0.5) * 100; // y
                posArray[i+2] = (Math.random() - 0.5) * 150; // z
                
                velocityArray.push({
                    y: -0.05 - Math.random() * 0.1,
                    x: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                });
            }

            snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const snowMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                map: particleTexture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            snowSystem = new THREE.Points(snowGeo, snowMat);
            snowSystem.userData = { velocities: velocityArray };
            scene.add(snowSystem);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- Firework System ---
        function createFirework() {
            // Random vibrant colors
            const colors = [0xff00ff, 0x00ffff, 0xffff00, 0xffaa00, 0xffffff];
            const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
            
            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            // Spawn random position in sky background
            const startX = (Math.random() - 0.5) * 120;
            const startY = (Math.random() * 30) + 10; 
            const startZ = -40 - Math.random() * 40; 

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = startX;
                positions[i * 3 + 1] = startY;
                positions[i * 3 + 2] = startZ;
                
                // Spherical explosion velocity
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 0.3 + Math.random() * 0.5;
                
                velocities.push({
                    x: speed * Math.sin(phi) * Math.cos(theta),
                    y: speed * Math.sin(phi) * Math.sin(theta),
                    z: speed * Math.cos(phi)
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                size: 1.2,
                color: color,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                map: particleTexture,
                depthWrite: false
            });

            const firework = new THREE.Points(geometry, material);
            firework.userData = { velocities: velocities, life: 1.0, decay: 0.01 + Math.random() * 0.02 };
            scene.add(firework);
            fireworks.push(firework);
        }

        function updateFireworks() {
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                fw.userData.life -= fw.userData.decay; // Fade out
                fw.material.opacity = fw.userData.life;

                const positions = fw.geometry.attributes.position.array;
                const vels = fw.userData.velocities;

                for (let j = 0; j < vels.length; j++) {
                    positions[j * 3] += vels[j].x;
                    positions[j * 3 + 1] += vels[j].y;
                    positions[j * 3 + 2] += vels[j].z;
                    
                    vels[j].y -= 0.015; // Gravity
                    vels[j].x *= 0.98; // Air resistance
                    vels[j].z *= 0.98;
                }
                fw.geometry.attributes.position.needsUpdate = true;

                if (fw.userData.life <= 0) {
                    scene.remove(fw);
                    geometry = fw.geometry;
                    material = fw.material;
                    geometry.dispose();
                    material.dispose();
                    fireworks.splice(i, 1);
                }
            }
        }

        // Ice Shard Fragments
        function createIceFragments() {
            const count = 35;
            const group = new THREE.Group();
            group.visible = false;
            const list = [];
            for (let i = 0; i < count; i++) {
                // Irregular triangle shards
                const geo = new THREE.ConeGeometry(0.3 + Math.random()*0.5, 0, 3); 
                const mat = new THREE.MeshPhysicalMaterial({ 
                    color: 0xa5f3fc, 
                    transmission: 0.9, 
                    opacity: 1, 
                    metalness: 0.1,
                    roughness: 0.1,
                    clearcoat: 1.0,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set((Math.random()-0.5)*8, (Math.random()-0.5)*10, (Math.random()-0.5)*1);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                
                group.add(mesh);
                // Increased explosion velocity
                list.push({ 
                    mesh, 
                    origPos: mesh.position.clone(), 
                    vel: new THREE.Vector3((Math.random()-0.5)*1.2, (Math.random()-0.5)*1.2, (Math.random()+0.2)*1.0),
                    rotVel: new THREE.Vector3((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3)
                });
            }
            return { group, list };
        }

        function createGallery(urls) {
            // Cleanup existing
            while(galleryGroup.children.length > 0) galleryGroup.remove(galleryGroup.children[0]);
            images = [];
            currentImageCount = urls.length;
            const loader = new THREE.TextureLoader();

            urls.forEach((url, i) => {
                const angle = (i / currentImageCount) * Math.PI * 2;
                
                // --- Image Frame ---
                const geometry = new THREE.PlaneGeometry(8, 10);
                const texture = loader.load(url);
                const material = new THREE.MeshStandardMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide, 
                    roughness: 0.4,
                    metalness: 0.1
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Add Glow Border
                const borderGeo = new THREE.PlaneGeometry(8.2, 10.2);
                const borderMat = new THREE.MeshBasicMaterial({ color: 0x22d3ee, side: THREE.BackSide });
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.05;
                mesh.add(border);

                const frameGroup = new THREE.Group();
                frameGroup.add(mesh);
                
                // Ice Fragments
                const frags = createIceFragments();
                frameGroup.add(frags.group);
                
                // Positioning
                const posX = Math.sin(angle) * RADIUS;
                const posZ = Math.cos(angle) * RADIUS;
                frameGroup.position.set(posX, 0, posZ);
                frameGroup.lookAt(0, 0, 0);
                
                galleryGroup.add(frameGroup);
                images.push({ 
                    group: frameGroup, 
                    mesh, 
                    frags, 
                    origPos: new THREE.Vector3(posX, 0, posZ), 
                    origRot: frameGroup.rotation.clone() 
                });
            });
        }

        // --- File Upload ---
        document.getElementById('image-upload').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            const urls = []; let loaded = 0;
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (ev) => { urls.push(ev.target.result); if (++loaded === files.length) createGallery(urls); };
                reader.readAsDataURL(file);
            });
        });

        // --- Hand Tracking Logic ---
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            if (gestureCooldown > 0) gestureCooldown--;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                const indexTip = hand[8], thumbTip = hand[4], palmBase = hand[0];
                
                // Check Fist (Ice Shatter + Fireworks)
                const isFist = [8, 12, 16, 20].every(id => hand[id].y > hand[id-2].y);
                isFistActive = isFist;

                if (!isFist) {
                    const isPalmOpen = [8,12,16,20].every(id => Math.hypot(hand[id].x - palmBase.x, hand[id].y - palmBase.y) > 0.18);
                    const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);

                    // Click/Pinch
                    if (pinchDist < 0.04 && gestureCooldown === 0) {
                        isFocusMode = !isFocusMode;
                        if (isFocusMode) { focusedIndex = activeIndex; focusRotationY = 0; focusScale = 1.6; }
                        gestureCooldown = 40;
                    }

                    // Movement
                    const handSize = Math.hypot(hand[5].x - hand[17].x, hand[5].y - hand[17].y);
                    if (!isFocusMode) {
                        if (lastHandPos) {
                            targetRotation -= (indexTip.x - lastHandPos) * (isPalmOpen ? 6 : 10);
                        }
                        targetZoom = 55 - (handSize * 150);
                        targetZoom = Math.min(Math.max(targetZoom, 20), 70);
                    } else {
                        if (lastHandPos) focusRotationY += (indexTip.x - lastHandPos) * 5;
                        focusScale = Math.min(Math.max(handSize * 12, 0.5), 3);
                    }
                    lastHandPos = indexTip.x;
                }
            } else { lastHandPos = null; isFistActive = false; }
        }

        // --- Animation Loop ---
        let activeIndex = 0;
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            // Camera & Gallery Movement
            currentRotation += (targetRotation - currentRotation) * 0.1;
            if (!isFocusMode) galleryGroup.rotation.y = currentRotation;
            currentZoom += (targetZoom - currentZoom) * 0.08;
            camera.position.z = currentZoom;

            // Trigger Fireworks if Fist is Active
            if (isFistActive && Math.random() > 0.92) {
                createFirework();
            }
            updateFireworks();

            // Determine active image
            if (currentImageCount > 0) {
                const normRot = ((currentRotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                activeIndex = Math.round(((Math.PI * 2) - normRot) / (Math.PI * 2) * currentImageCount) % currentImageCount;

                images.forEach((img, i) => {
                    if (isFistActive) {
                        // Shatter Logic
                        img.mesh.visible = false;
                        img.frags.group.visible = true;
                        img.frags.list.forEach(f => {
                            f.mesh.material.opacity = 1;
                            f.mesh.position.add(f.vel);
                            f.mesh.rotation.x += f.rotVel.x;
                            f.mesh.rotation.y += f.rotVel.y;
                            f.mesh.position.y -= 0.05; // Gravity
                        });
                    } else {
                        // Restore Logic
                        img.mesh.visible = true;
                        img.frags.list.forEach(f => {
                            f.mesh.position.lerp(f.origPos, 0.1);
                            f.mesh.rotation.set(0,0,0);
                        });
                        img.frags.group.visible = false;

                        // Focus/Idle Logic
                        if (isFocusMode && i === focusedIndex) {
                            const worldTarget = new THREE.Vector3(0, 0, currentZoom - 12);
                            img.group.position.lerp(galleryGroup.worldToLocal(worldTarget), 0.1);
                            img.group.rotation.y = -galleryGroup.rotation.y + focusRotationY;
                            img.mesh.scale.lerp(new THREE.Vector3(focusScale, focusScale, 1), 0.1);
                        } else {
                            img.group.position.lerp(img.origPos, 0.1);
                            img.group.rotation.y += (img.origRot.y - img.group.rotation.y) * 0.1;
                            img.mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                        }
                    }
                });
            }

            // Animate Snow
            if (snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array;
                const vels = snowSystem.userData.velocities;
                for(let i=0; i<vels.length; i++) {
                    positions[i*3+1] += vels[i].y; // Y movement
                    positions[i*3] += Math.sin(time + i) * 0.02 + vels[i].x; // X drift
                    
                    if (positions[i*3+1] < -50) {
                        positions[i*3+1] = 50; // Reset to top
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
                snowSystem.rotation.y = time * 0.05;
            }

            renderer.render(scene, camera);
        }

        // --- Initialization ---
        window.onload = () => {
            initThree();
            
            // Seed default images
            const defaults = Array.from({length: 8}, (_, i) => `https://picsum.photos/seed/${i+2026}/600/800`);
            createGallery(defaults);
            animate();

            // Setup Mediapipe
            const video = document.getElementById('input_video');
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.75, minTrackingConfidence: 0.75 });
            hands.onResults(onResults);
            
            const cameraUtils = new Camera(video, { 
                onFrame: async () => { await hands.send({ image: video }); }, 
                width: 640, 
                height: 480 
            });
            cameraUtils.start();
        };
    </script>
</body>
</html>