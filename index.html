<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOUR 3D GALLERY</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Inter', sans-serif; }
        
        /* Camera Feed View */
        #video-container { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 120px; 
            height: 90px; 
            border-radius: 12px; 
            overflow: hidden; 
            border: 2px solid rgba(255,255,255,0.1); 
            z-index: 10; 
            transform: scaleX(-1);
            transition: all 0.3s;
        }
        @media (min-width: 768px) { #video-container { width: 180px; height: 135px; } }

        #input_video { width: 100%; height: 100%; object-fit: cover; }

        /* Floating UI Controls */
        #ui-controls { 
            position: absolute; 
            bottom: 30px; 
            left: 50%; 
            transform: translateX(-50%); 
            display: flex; 
            gap: 15px; 
            z-index: 20; 
        }

        .icon-btn { 
            width: 50px; 
            height: 50px; 
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(10px); 
            border: 1px solid rgba(255, 255, 255, 0.2); 
            border-radius: 50%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 1.2rem; 
            cursor: pointer; 
            transition: all 0.3s;
            color: white;
        }
        .icon-btn:hover { background: var(--accent-bg); border-color: var(--accent-color); transform: scale(1.1); }
        
        /* Menu & Instructions Overlay */
        #menu-toggle { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            z-index: 100; 
        }

        #instructions-overlay { 
            position: fixed; 
            top: 0; 
            right: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0, 0, 0, 0.9); 
            z-index: 90; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            pointer-events: none; 
            clip-path: circle(0% at 95% 5%);
            transition: clip-path 0.7s cubic-bezier(0.77, 0, 0.175, 1);
        }

        #instructions-overlay.open { 
            clip-path: circle(150% at 95% 5%); 
            pointer-events: auto; 
        }

        .instruction-card { 
            padding: 2rem; 
            max-width: 400px; 
            text-align: center; 
            color: white;
        }

        .gesture-item { 
            background: rgba(255,255,255,0.05); 
            padding: 12px; 
            border-radius: 12px; 
            margin-bottom: 10px; 
            display: flex; 
            align-items: center; 
            gap: 15px;
            font-size: 0.9rem;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #loading { position: fixed; inset: 0; background: #050505; display: flex; align-items: center; justify-content: center; z-index: 1000; flex-direction: column; }
        .spinner { border: 3px solid rgba(255,255,255,0.1); border-top: 3px solid var(--accent-color); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        input[type="file"] { display: none; }

        :root {
            --accent-color: #ffb6c1;
            --accent-glow: rgba(255,182,193,0.4);
            --accent-bg: rgba(255,182,193,0.15);
        }
        .christmas-theme { --accent-color: #ff3e3e; --accent-bg: rgba(255,62,62,0.15); }
        .newyear-theme { --accent-color: #ffd700; --accent-bg: rgba(255,215,0,0.15); }
    </style>
</head>
<body class="default-theme">

    <div id="loading">
        <div class="spinner"></div>
        <p id="loading-text" class="text-white/50 tracking-widest text-xs uppercase">Initializing Gallery...</p>
    </div>

    <!-- Header Title -->
    <div class="absolute top-6 left-6 z-20 pointer-events-none">
        <h1 id="gallery-title" class="text-xl md:text-2xl font-extralight tracking-[0.2em] text-white opacity-60">YOUR GALLERY</h1>
        <p id="holiday-badge" class="text-[10px] tracking-[0.3em] text-white/40 uppercase mt-1"></p>
    </div>

    <!-- Top Right Menu Button -->
    <button id="menu-toggle" class="icon-btn" title="Instructions">
        <span id="menu-icon">‚ùî</span>
    </button>

    <!-- Instructions Overlay -->
    <div id="instructions-overlay">
        <div class="instruction-card">
            <h2 class="text-2xl mb-6 font-light tracking-widest">HAND GESTURES</h2>
            <div id="instruction-list">
                <div class="gesture-item"><span>üëÜ</span> Point and move to scroll</div>
                <div class="gesture-item"><span>‚úã</span> Open palm to rotate gallery</div>
                <div class="gesture-item"><span>ü§å</span> Pinch to focus image</div>
                <div class="gesture-item"><span>‚úä</span> Fist to shatter images</div>
                <div class="gesture-item"><span>‚ÜïÔ∏è</span> Z-axis movement to zoom</div>
            </div>
            <button id="close-menu" class="mt-8 text-xs uppercase tracking-widest text-white/40 hover:text-white transition-colors underline">Close Menu</button>
        </div>
    </div>

    <!-- Bottom Controls -->
    <div id="ui-controls">
        <button id="ui-visibility-btn" class="icon-btn" title="Toggle UI Labels">üëÅÔ∏è</button>
        <label for="image-upload" class="icon-btn" title="Select Images">
            üñºÔ∏è
        </label>
        <input type="file" id="image-upload" multiple accept="image/*">
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>

    <script>
        // --- Theme Logic ---
        const now = new Date();
        const month = now.getMonth() + 1; 
        const date = now.getDate();
        
        let themeType = "default";
        if (month === 12 && date >= 24 && date <= 26) themeType = "christmas";
        else if ((month === 12 && date >= 31) || (month === 1 && date <= 2)) themeType = "newyear";

        const galleryTitle = document.getElementById('gallery-title');
        const holidayBadge = document.getElementById('holiday-badge');
        let accentHex = 0xffb6c1;
        let confettiColors = [0xffb6c1, 0xffffff, 0xffd1dc];

        if (themeType === "christmas") {
            document.body.classList.add('christmas-theme');
            galleryTitle.innerHTML = "üéÖ MERRY <span class='text-red-500'>CHRISTMAS</span> üéÑ";
            holidayBadge.innerText = "‚ú® Christmas Edition üéÅ";
            accentHex = 0xff3e3e;
            confettiColors = [0xff3e3e, 0x2e8b57, 0xffffff];
        } else if (themeType === "newyear") {
            document.body.classList.add('newyear-theme');
            galleryTitle.innerHTML = "‚ú® HAPPY <span class='text-yellow-400'>NEW YEAR</span> üéÜ";
            holidayBadge.innerText = "ü•Ç New Year Edition üéá";
            accentHex = 0xffd700;
            confettiColors = [0xffd700, 0xffffff, 0xc0c0c0];
        }

        // --- UI Logic ---
        const menuBtn = document.getElementById('menu-toggle');
        const overlay = document.getElementById('instructions-overlay');
        const closeBtn = document.getElementById('close-menu');
        const menuIcon = document.getElementById('menu-icon');

        menuBtn.addEventListener('click', () => {
            const isOpen = overlay.classList.toggle('open');
            menuIcon.innerText = isOpen ? '‚úï' : '‚ùî';
        });

        closeBtn.addEventListener('click', () => {
            overlay.classList.remove('open');
            menuIcon.innerText = '‚ùî';
        });

        const uiToggle = document.getElementById('ui-visibility-btn');
        let uiLabelsHidden = false;
        uiToggle.addEventListener('click', () => {
            uiLabelsHidden = !uiLabelsHidden;
            galleryTitle.style.opacity = uiLabelsHidden ? '0' : '0.6';
            holidayBadge.style.opacity = uiLabelsHidden ? '0' : '0.4';
            uiToggle.style.opacity = uiLabelsHidden ? '0.4' : '1';
        });

        // --- Three.js & Hand Tracking ---
        const RADIUS = 20;
        let scene, camera, renderer, galleryGroup, particles;
        let emojiSprites = []; 
        let images = [];
        let currentImageCount = 0;
        let targetRotation = 0, currentRotation = 0;
        let targetZoom = 40, currentZoom = 40;
        let isFocusMode = false, focusedIndex = -1;
        let focusRotationY = 0, focusScale = 1;
        let lastHandPos = null, gestureCooldown = 0;
        let isFistActive = false;

        function createEmojiTexture(emoji) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = '100px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = currentZoom;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const pLight = new THREE.PointLight(accentHex, 2, 100);
            pLight.position.set(0, 20, 20);
            scene.add(pLight);

            galleryGroup = new THREE.Group();
            scene.add(galleryGroup);

            // Falling Sprites / Background Particles
            if (themeType !== "default") {
                const holidayEmojis = themeType === "christmas" ? ['üéÑ', 'üéÅ', '‚ú®', '‚ùÑÔ∏è'] : ['üéÜ', 'üéá', '‚ú®', 'ü•Ç'];
                const textures = holidayEmojis.map(e => createEmojiTexture(e));
                for (let i = 0; i < 80; i++) {
                    const material = new THREE.SpriteMaterial({ map: textures[i % textures.length], transparent: true, opacity: 0.8 });
                    const sprite = new THREE.Sprite(material);
                    sprite.position.set((Math.random()-0.5)*120, Math.random()*100-50, (Math.random()-0.5)*100);
                    sprite.scale.set(1.5, 1.5, 1);
                    sprite.userData = { velocity: 0.05 + Math.random()*0.1, drift: (Math.random()-0.5)*0.02 };
                    scene.add(sprite);
                    emojiSprites.push(sprite);
                }
            } else {
                const pGeo = new THREE.BufferGeometry();
                const pPos = new Float32Array(1000 * 3);
                for(let i=0; i<1000*3; i++) pPos[i] = (Math.random() - 0.5) * 150;
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                particles = new THREE.Points(pGeo, new THREE.PointsMaterial({ color: accentHex, size: 0.05, transparent: true, opacity: 0.3 }));
                scene.add(particles);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createFragments(color) {
            const count = 30;
            const group = new THREE.Group();
            group.visible = false;
            const list = [];
            for (let i = 0; i < count; i++) {
                const geo = new THREE.PlaneGeometry(0.8, 0.8);
                const mat = new THREE.MeshStandardMaterial({ color: confettiColors[i % confettiColors.length], side: THREE.DoubleSide, transparent: true, opacity: 0 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set((Math.random()-0.5)*8, (Math.random()-0.5)*10, 0);
                group.add(mesh);
                list.push({ mesh, origPos: mesh.position.clone(), vel: new THREE.Vector3((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3) });
            }
            return { group, list };
        }

        function createGallery(urls) {
            while(galleryGroup.children.length > 0) galleryGroup.remove(galleryGroup.children[0]);
            images = [];
            currentImageCount = urls.length;
            const loader = new THREE.TextureLoader();
            urls.forEach((url, i) => {
                const angle = (i / currentImageCount) * Math.PI * 2;
                const geometry = new THREE.PlaneGeometry(8, 10);
                const texture = loader.load(url);
                const material = new THREE.MeshStandardMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
                const mesh = new THREE.Mesh(geometry, material);
                const frame = new THREE.Group();
                frame.add(mesh);
                
                const frags = createFragments(accentHex);
                frame.add(frags.group);
                
                const posX = Math.sin(angle) * RADIUS;
                const posZ = Math.cos(angle) * RADIUS;
                frame.position.set(posX, 0, posZ);
                frame.lookAt(0, 0, 0);
                
                galleryGroup.add(frame);
                images.push({ group: frame, mesh, frags, origPos: new THREE.Vector3(posX, 0, posZ), origRot: frame.rotation.clone() });
            });
        }

        document.getElementById('image-upload').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            const urls = []; let loaded = 0;
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (ev) => { urls.push(ev.target.result); if (++loaded === files.length) createGallery(urls); };
                reader.readAsDataURL(file);
            });
        });

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            if (gestureCooldown > 0) gestureCooldown--;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                const indexTip = hand[8], thumbTip = hand[4], palmBase = hand[0];
                
                const isFist = [8, 12, 16, 20].every(id => hand[id].y > hand[id-2].y);
                isFistActive = isFist;

                if (!isFist) {
                    const isPalmOpen = [8,12,16,20].every(id => Math.hypot(hand[id].x - palmBase.x, hand[id].y - palmBase.y) > 0.18);
                    const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);

                    if (pinchDist < 0.04 && gestureCooldown === 0) {
                        isFocusMode = !isFocusMode;
                        if (isFocusMode) { focusedIndex = activeIndex; focusRotationY = 0; focusScale = 1.6; }
                        gestureCooldown = 40;
                    }

                    const handSize = Math.hypot(hand[5].x - hand[17].x, hand[5].y - hand[17].y);
                    if (!isFocusMode) {
                        if (lastHandPos) {
                            targetRotation -= (indexTip.x - lastHandPos) * (isPalmOpen ? 8 : 12);
                        }
                        targetZoom = 55 - (handSize * 150);
                        targetZoom = Math.min(Math.max(targetZoom, 20), 70);
                    } else {
                        if (lastHandPos) focusRotationY += (indexTip.x - lastHandPos) * 5;
                        focusScale = Math.min(Math.max(handSize * 12, 0.5), 3);
                    }
                    lastHandPos = indexTip.x;
                }
            } else { lastHandPos = null; isFistActive = false; }
        }

        let activeIndex = 0;
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            currentRotation += (targetRotation - currentRotation) * 0.1;
            if (!isFocusMode) galleryGroup.rotation.y = currentRotation;
            currentZoom += (targetZoom - currentZoom) * 0.08;
            camera.position.z = currentZoom;

            if (currentImageCount > 0) {
                const normRot = ((currentRotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                activeIndex = Math.round(((Math.PI * 2) - normRot) / (Math.PI * 2) * currentImageCount) % currentImageCount;

                images.forEach((img, i) => {
                    if (isFistActive) {
                        img.mesh.visible = false;
                        img.frags.group.visible = true;
                        img.frags.list.forEach(f => {
                            f.mesh.material.opacity += (0.8 - f.mesh.material.opacity) * 0.1;
                            f.mesh.position.add(f.vel);
                            f.mesh.position.y -= 0.02;
                        });
                    } else {
                        img.mesh.visible = true;
                        img.frags.list.forEach(f => {
                            f.mesh.material.opacity *= 0.8;
                            f.mesh.position.lerp(f.origPos, 0.1);
                        });
                        if (img.frags.list[0].mesh.material.opacity < 0.01) img.frags.group.visible = false;

                        if (isFocusMode && i === focusedIndex) {
                            const worldTarget = new THREE.Vector3(0, 0, currentZoom - 12);
                            img.group.position.lerp(galleryGroup.worldToLocal(worldTarget), 0.1);
                            img.group.rotation.y = -galleryGroup.rotation.y + focusRotationY;
                            img.mesh.scale.lerp(new THREE.Vector3(focusScale, focusScale, 1), 0.1);
                            img.mesh.material.opacity = 1;
                        } else {
                            img.group.position.lerp(img.origPos, 0.1);
                            img.group.rotation.y += (img.origRot.y - img.group.rotation.y) * 0.1;
                            img.mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                            img.mesh.material.opacity += ((isFocusMode ? 0.1 : 1.0) - img.mesh.material.opacity) * 0.1;
                        }
                    }
                });
            }

            // Animate Falling Emojis
            if (themeType !== "default") {
                emojiSprites.forEach(sprite => {
                    sprite.position.y -= sprite.userData.velocity;
                    sprite.position.x += Math.sin(time + sprite.position.y) * sprite.userData.drift;
                    if (sprite.position.y < -50) sprite.position.y = 50;
                });
            } else if (particles) {
                particles.rotation.y += 0.0003;
            }

            renderer.render(scene, camera);
        }

        window.onload = () => {
            initThree();
            animate();
            const defaults = Array.from({length: 6}, (_, i) => `https://picsum.photos/seed/${i+123}/800/1000`);
            createGallery(defaults);

            const video = document.getElementById('input_video');
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.75, minTrackingConfidence: 0.75 });
            hands.onResults(onResults);
            new Camera(video, { onFrame: async () => { await hands.send({ image: video }); }, width: 640, height: 480 }).start();
        };
    </script>
</body>
</html>